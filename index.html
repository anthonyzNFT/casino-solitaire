<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Solitaire</title>
    <style>
        body { margin: 0; background: #2F2F2F; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #gameContainer { flex: 1; display: flex; justify-content: center; align-items: center; width: 100%; }
        canvas { border: 1px solid #D9C2A7; max-width: 90vw; max-height: 90vh; }
        header { background: #4A704A; color: #D9C2A7; text-align: center; padding: 10px; font-size: 5vw; font-family: Arial, sans-serif; }
        footer { background: #2F2F2F; color: #D9C2A7; text-align: center; padding: 5px; font-size: 2vw; font-family: Arial, sans-serif; }
        @media (max-width: 600px) {
            canvas { max-width: 95vw; max-height: 70vh; }
            header { font-size: 6vw; }
            footer { font-size: 2.5vw; }
        }
    </style>
</head>
<body>
    <header>Casino Society</header>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <footer>© 2025 Casino Society - All Rights Reserved</footer>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Dynamic canvas sizing
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.7;
            cardWidth = canvas.width / 12;
            cardHeight = cardWidth * 1.428; // Maintain aspect ratio
            render();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Card properties
        let cardWidth = canvas.width / 12;
        let cardHeight = cardWidth * 1.428;
        const suits = ['♠', '♥', '♣', '♦'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const colors = { '♠': '#D9C2A7', '♣': '#D9C2A7', '♥': '#D9C2A7', '♦': '#D9C2A7' };

        // Game state
        let deck = [];
        let tableau = [[], [], [], [], [], [], []];
        let stock = [];
        let waste = [];
        let foundations = [[], [], [], [], []];
        let draggingCards = [];
        let dragOffset = { x: 0, y: 0 };
        let dragSource = null;

        // Initialize deck
        function createDeck() {
            deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank, faceUp: false });
                }
            }
            shuffle(deck);
        }

        // Shuffle array
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Deal cards to tableau
        function deal() {
            for (let i = 0; i < 7; i++) {
                for (let j = i; j < 7; j++) {
                    let card = deck.pop();
                    card.faceUp = (i === j);
                    tableau[j].push(card);
                }
            }
            stock = deck;
        }

        // Draw card back
        function drawCardBack(x, y) {
            ctx.fillStyle = '#2F2F2F'; // Dark background
            ctx.fillRect(x, y, cardWidth, cardHeight);
            ctx.strokeStyle = '#4A704A';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cardWidth, cardHeight);
            ctx.fillStyle = '#D9C2A7';
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    ctx.beginPath();
                    ctx.arc(x + 10 + j * 12, y + 10 + i * 18, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Draw card
        function drawCard(x, y, card, highlight = false) {
            if (!card.faceUp) {
                drawCardBack(x, y);
                return;
            }
            ctx.fillStyle = '#4A704A';
            ctx.fillRect(x, y, cardWidth, cardHeight);
            ctx.strokeStyle = highlight ? '#D9C2A7' : '#4A704A';
            ctx.lineWidth = highlight ? 3 : 1;
            ctx.strokeRect(x, y, cardWidth, cardHeight);
            ctx.fillStyle = colors[card.suit];
            ctx.font = `${cardWidth / 4}px Arial`;
            ctx.fillText(`${card.rank}${card.suit}`, x + 10, y + cardHeight / 3);
        }

        // Render game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw stock
            if (stock.length > 0) {
                drawCard(50, 50, stock[stock.length - 1]);
            }

            // Draw waste
            if (waste.length > 0) {
                drawCard(150, 50, waste[waste.length - 1]);
            }

            // Draw foundations
            for (let i = 0; i < 4; i++) {
                if (foundations[i].length > 0) {
                    drawCard(300 + i * (cardWidth + 20), 50, foundations[i][foundations[i].length - 1]);
                } else {
                    ctx.strokeStyle = '#4A704A';
                    ctx.strokeRect(300 + i * (cardWidth + 20), 50, cardWidth, cardHeight);
                }
            }

            // Draw tableau
            for (let i = 0; i < 7; i++) {
                let y = 200;
                for (let card of tableau[i]) {
                    drawCard(50 + i * (cardWidth + 20), y, card);
                    y += cardHeight / 3;
                }
            }

            // Draw dragging cards
            if (draggingCards.length > 0) {
                draggingCards.forEach((card, idx) => {
                    drawCard(card.x, card.y + idx * (cardHeight / 6), card.card, true);
                });
            }
        }

        // Get card stack at position
        function getCardStackAt(x, y) {
            // Check waste
            if (waste.length > 0 && x >= 150 && x <= 150 + cardWidth && y >= 50 && y <= 50 + cardHeight) {
                return { cards: [waste[waste.length - 1]], source: 'waste' };
            }

            // Check tableau
            for (let i = 0; i < 7; i++) {
                let ty = 200;
                let stack = [];
                for (let j = tableau[i].length - 1; j >= 0; j--) {
                    if (tableau[i][j].faceUp && x >= 50 + i * (cardWidth + 20) && x <= 50 + i * (cardWidth + 20) + cardWidth && y >= ty && y <= ty + cardHeight) {
                        stack.push(tableau[i][j]);
                    } else if (stack.length > 0) break;
                    ty += cardHeight / 3;
                }
                if (stack.length > 0) {
                    return { cards: stack, source: 'tableau', pile: i, index: tableau[i].length - stack.length };
                }
            }
            return null;
        }

        // Check if move is valid
        function isValidMove(card, targetPile, pileType) {
            if (pileType === 'foundation') {
                let pile = foundations[targetPile];
                if (pile.length === 0) return card.rank === 'A';
                let topCard = pile[pile.length - 1];
                return card.suit === topCard.suit && ranks.indexOf(card.rank) === ranks.indexOf(topCard.rank) + 1;
            } else if (pileType === 'tableau') {
                let pile = tableau[targetPile];
                if (pile.length === 0) return card.rank === 'K';
                let topCard = pile[pile.length - 1];
                return colors[card.suit] !== colors[topCard.suit] && ranks.indexOf(card.rank) === ranks.indexOf(topCard.rank) - 1;
            }
            return false;
        }

        // Mouse/Touch events
        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('touchstart', startDrag, { passive: false });
        canvas.addEventListener('touchmove', drag, { passive: false });
        canvas.addEventListener('touchend', endDrag);

        function startDrag(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (e.type.includes('touch') ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.type.includes('touch') ? e.touches[0].clientY : e.clientY) - rect.top;

            // Check stock click
            if (x >= 50 && x <= 50 + cardWidth && y >= 50 && y <= 50 + cardHeight && stock.length > 0) {
                let card = stock.pop();
                card.faceUp = true;
                waste.push(card);
                render();
                return;
            }

            let target = getCardStackAt(x, y);
            if (target && target.cards[0].faceUp) {
                draggingCards = target.cards.map(card => ({
                    card,
                    x: x - cardWidth / 2,
                    y: y - cardHeight / 2
                }));
                dragSource = target;
                dragOffset = { x: x - (50 + (target.pile || 0) * (cardWidth + 20)), y: y - (target.source === 'waste' ? 50 : 200 + (target.index) * (cardHeight / 3)) };
            }
            render();
        }

        function drag(e) {
            if (draggingCards.length > 0) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = (e.type.includes('touch') ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.type.includes('touch') ? e.touches[0].clientY : e.clientY) - rect.top;
                draggingCards.forEach(card => {
                    card.x = x - dragOffset.x;
                    card.y = y - dragOffset.y;
                });
                render();
            }
        }

        function endDrag(e) {
            if (draggingCards.length > 0) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = (e.type.includes('touch') ? e.changedTouches[0].clientX : e.clientX) - rect.left;
                const y = (e.type.includes('touch') ? e.changedTouches[0].clientY : e.clientY) - rect.top;

                let moved = false;

                // Check foundations
                for (let i = 0; i < 4; i++) {
                    if (x >= 300 + i * (cardWidth + 20) && x <= 300 + i * (cardWidth + 20) + cardWidth && y >= 50 && y <= 50 + cardHeight) {
                        if (isValidMove(draggingCards[0].card, i, 'foundation')) {
                            foundations[i].push(draggingCards[0].card);
                            if (dragSource.source === 'waste') waste.pop();
                            else if (dragSource.source === 'tableau') {
                                for (let j = 0; j < draggingCards.length; j++) {
                                    tableau[dragSource.pile].pop();
                                }
                                if (tableau[dragSource.pile].length > 0) {
                                    tableau[dragSource.pile][tableau[dragSource.pile].length - 1].faceUp = true;
                                }
                            }
                            moved = true;
                        }
                        break;
                    }
                }

                // Check tableau
                if (!moved) {
                    for (let i = 0; i < 7; i++) {
                        let ty = tableau[i].length === 0 ? 200 : 200 + (tableau[i].length - 1) * (cardHeight / 3);
                        if (x >= 50 + i * (cardWidth + 20) && x <= 50 + i * (cardWidth + 20) + cardWidth && y >= ty && y <= ty + cardHeight + (cardHeight / 3)) {
                            if (isValidMove(draggingCards[0].card, i, 'tableau')) {
                                draggingCards.forEach(card => tableau[i].push(card.card));
                                if (dragSource.source === 'waste') waste.pop();
                                else if (dragSource.source === 'tableau') {
                                    for (let j = 0; j < draggingCards.length; j++) {
                                        tableau[dragSource.pile].pop();
                                    }
                                    if (tableau[dragSource.pile].length > 0) {
                                        tableau[dragSource.pile][tableau[dragSource.pile].length - 1].faceUp = true;
                                    }
                                }
                                moved = true;
                            }
                            break;
                        }
                    }
                }

                draggingCards = [];
                dragSource = null;
                render();
            }
        }

        // Start game
        createDeck();
        deal();
        render();
    </script>
</body>
</html>
